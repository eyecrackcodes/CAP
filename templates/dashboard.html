{% extends "base.html" %} {% block title %}PPL Performance Dashboard{% endblock
%} {% block head %}
<!-- Add DataTables CSS -->
<link
  rel="stylesheet"
  type="text/css"
  href="https://cdn.datatables.net/1.11.5/css/dataTables.bootstrap5.min.css"
/>
<style>
  /* Style for sortable headers */
  th.sorting {
    cursor: pointer;
    position: relative;
    padding-right: 25px !important; /* Make room for the icons */
  }

  /* Add sort indicators */
  th.sorting:after,
  th.sorting_asc:after,
  th.sorting_desc:after {
    position: absolute;
    right: 8px;
    top: calc(50% - 8px);
    display: block;
    font-weight: bold;
    font-size: 14px;
  }

  /* Default state - both arrows faded */
  th.sorting:after {
    content: "⇅";
    opacity: 0.5;
  }

  /* Ascending sort - up arrow highlighted */
  th.sorting_asc:after {
    content: "▲";
    opacity: 1;
    color: #0d6efd;
  }

  /* Descending sort - down arrow highlighted */
  th.sorting_desc:after {
    content: "▼";
    opacity: 1;
    color: #0d6efd;
  }

  /* Additional styles to ensure sort indicators are visible */
  table.dataTable thead .sorting:after,
  table.dataTable thead .sorting_asc:after,
  table.dataTable thead .sorting_desc:after,
  table.dataTable thead .sorting_asc_disabled:after,
  table.dataTable thead .sorting_desc_disabled:after {
    display: block !important;
    visibility: visible !important;
  }

  /* Fix table width issues with DataTables */
  .table-responsive {
    min-height: 300px;
  }

  /* Highlight active sort column */
  th.sorting_asc,
  th.sorting_desc {
    background-color: rgba(0, 0, 0, 0.05);
    font-weight: bold;
  }

  /* Better styling for DataTables search box */
  .dataTables_filter {
    margin-bottom: 15px;
    text-align: right;
  }

  .dataTables_filter input {
    margin-left: 10px;
    padding: 5px 10px;
    border-radius: 4px;
    border: 1px solid #ced4da;
  }

  /* Explicit sort icon styling */
  .sort-icon {
    position: absolute;
    right: 8px;
    top: calc(50% - 8px);
    font-size: 14px;
  }

  /* Ensure header text doesn't overlap with sort icon */
  table.dataTable thead th {
    position: relative;
    padding-right: 25px !important;
  }
</style>
{% endblock %} {% block content %}
<div class="container-fluid">
  <!-- Header Section -->
  <div class="row mb-4">
    <div class="col-6">
      <h1>PPL Performance Dashboard</h1>
    </div>
    <div class="col-6 text-end">
      <div class="last-sync-info">
        <span id="lastSyncTime">Data last synced: Never</span>
        <button id="manualSyncBtn" class="btn btn-sm btn-primary ms-2">
          <i class="bi bi-arrow-repeat"></i> Sync from Looker
        </button>
      </div>
    </div>
  </div>

  <!-- Filters Section -->
  <div class="card mb-4">
    <div class="card-body">
      <h5 class="card-title">Filters</h5>
      <form id="filterForm" class="row g-3">
        <div class="col-md-3">
          <label class="form-label">Division</label>
          <select class="form-select" id="divisionFilter">
            <option value="">All Divisions</option>
            <option value="Charlotte (CLT)">Charlotte (CLT)</option>
            <option value="Austin (ATX)">Austin (ATX)</option>
          </select>
        </div>
        <div class="col-md-3">
          <label class="form-label">Queue Type</label>
          <select class="form-select" id="queueFilter">
            <option value="">All Queues</option>
            <option value="Training">Training</option>
            <option value="Performance">Performance</option>
          </select>
        </div>
        <div class="col-md-3">
          <label class="form-label">Agent</label>
          <select class="form-select" id="agentFilter">
            <option value="">All Agents</option>
          </select>
        </div>
        <div class="col-md-3">
          <label class="form-label">Manager</label>
          <select class="form-select" id="managerFilter">
            <option value="">All Managers</option>
          </select>
        </div>
        <div class="col-md-12">
          <div class="form-check mt-2">
            <input class="form-check-input" type="checkbox" id="showInactive" />
            <label class="form-check-label" for="showInactive">
              Show inactive agents
            </label>
          </div>
        </div>
        <div class="col-md-12">
          <hr />
          <div class="row align-items-end">
            <div class="col-md-3">
              <label class="form-label">Quick Date Range</label>
              <select class="form-select" id="quickDateRange">
                <option value="7">Last 7 Days</option>
                <option value="14">Last 14 Days</option>
                <option value="30" selected>Last 30 Days</option>
                <option value="90">Last 90 Days</option>
                <option value="custom">Custom Range</option>
              </select>
            </div>
            <div class="col-md-3 custom-date-range d-none">
              <label class="form-label">Start Date</label>
              <input type="date" class="form-control" id="startDateFilter" />
            </div>
            <div class="col-md-3 custom-date-range d-none">
              <label class="form-label">End Date</label>
              <input type="date" class="form-control" id="endDateFilter" />
            </div>
            <div class="col-md-3">
              <button type="submit" class="btn btn-primary w-100">
                Apply Filters
              </button>
            </div>
          </div>
        </div>
      </form>
    </div>
  </div>

  <!-- Loading Indicator -->
  <div id="loadingIndicator" style="display: none" class="text-center p-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading dashboard data...</p>
  </div>

  <!-- Include this right after the loading indicator -->
  <div
    id="errorAlert"
    class="alert alert-danger"
    style="display: none"
    role="alert"
  >
    Error loading data. Please try again.
  </div>

  <div
    id="noAgentsMessage"
    class="alert alert-info text-center"
    style="display: none"
  >
    No agents found with the current filters. Try adjusting your filters.
  </div>

  <!-- Quick Stats Cards -->
  <div class="row mb-4">
    <div class="col-md-3">
      <div class="card bg-primary text-white">
        <div class="card-body">
          <h5 class="card-title">Break Even PPL</h5>
          <h2>130</h2>
          <p class="mb-0">17.4% CR × 65.0% PR × $1,150 AP</p>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card bg-success text-white">
        <div class="card-body">
          <h5 class="card-title">Target PPL</h5>
          <h2>164</h2>
          <p class="mb-0">22.5% CR × 65.0% PR × $1,150 AP</p>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card bg-info text-white">
        <div class="card-body">
          <h5 class="card-title">Average PPL</h5>
          <h2 id="avgPPL">0</h2>
          <p class="mb-0" id="avgPPLPeriod">Current period average</p>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card bg-warning text-dark">
        <div class="card-body">
          <h5 class="card-title">Total Agents</h5>
          <h2 id="totalAgents">0</h2>
          <p class="mb-0" id="agentBreakdown">Loading...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Performance Metrics -->
  <div class="row mb-4">
    <div class="col-md-6">
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Performance Distribution</h5>
          <div style="height: 300px">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">PPL Trend</h5>
          <div style="height: 300px">
            <canvas id="trendChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Agent Performance Table -->
  <div class="card">
    <div class="card-body">
      <h5 class="card-title">Agent Performance</h5>
      <div class="table-responsive">
        <table class="table table-striped" id="agentTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Division</th>
              <th>Queue</th>
              <th>Manager</th>
              <th>Status</th>
              <th>Leads Taken</th>
              <th>Close Rate</th>
              <th>PPL</th>
              <th>Total Premium</th>
              <th>Projected Annual Income</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<!-- Agent Details Modal -->
<div class="modal fade" id="agentDetailsModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Agent Performance Details</h5>
        <button
          type="button"
          class="btn-close"
          data-bs-dismiss="modal"
        ></button>
      </div>
      <div class="modal-body">
        <div id="agentDetailsLoading" class="d-none">
          <div class="text-center p-4">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading agent details...</p>
          </div>
        </div>
        <div id="agentDetailsError" class="d-none">
          <div class="alert alert-danger">
            Failed to load agent details. Please try again.
          </div>
        </div>
        <div id="agentDetailsContent">
          <!-- Agent Info Section -->
          <div class="agent-info mb-4">
            <div class="row">
              <div class="col-md-6">
                <h6 class="text-muted">Agent Information</h6>
                <table class="table table-sm">
                  <tr>
                    <th>Name:</th>
                    <td id="agentName"></td>
                  </tr>
                  <tr>
                    <th>Division:</th>
                    <td id="agentDivision"></td>
                  </tr>
                  <tr>
                    <th>Manager:</th>
                    <td id="agentManager"></td>
                  </tr>
                  <tr>
                    <th>Queue:</th>
                    <td id="agentQueue"></td>
                  </tr>
                </table>
              </div>
              <div class="col-md-6">
                <h6 class="text-muted">Performance Summary</h6>
                <div class="row">
                  <div class="col-6">
                    <div class="card bg-light">
                      <div class="card-body p-2 text-center">
                        <h3 class="mb-0" id="avgPPLDetails">0.00</h3>
                        <small class="text-muted">Average PPL</small>
                      </div>
                    </div>
                  </div>
                  <div class="col-6">
                    <div class="card bg-light">
                      <div class="card-body p-2 text-center">
                        <h3 class="mb-0" id="totalLeadsDetails">0</h3>
                        <small class="text-muted">Total Leads</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Charts Section -->
          <div class="row mb-4">
            <div class="col-md-6">
              <div class="card">
                <div class="card-body">
                  <h6 class="card-title">Performance Metrics</h6>
                  <div style="height: 300px; position: relative">
                    <canvas id="agentMetricsChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card">
                <div class="card-body">
                  <h6 class="card-title">PPL Trend</h6>
                  <div style="height: 300px; position: relative">
                    <canvas id="agentTrendChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Daily Performance Table -->
          <div class="card">
            <div class="card-body">
              <h6 class="card-title">Weekly Performance</h6>
              <div class="table-responsive">
                <table
                  class="table table-sm table-hover"
                  id="agentDetailsTable"
                >
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Leads</th>
                      <th>Close Rate</th>
                      <th>Place Rate</th>
                      <th>Avg Premium</th>
                      <th>PPL</th>
                      <th>Status</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <a href="#" class="btn btn-success" id="addPerformanceBtn"
          >Add Performance Data</a
        >
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Close
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %} {% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-trendline"></script>
<!-- Add DataTables JavaScript -->
<script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.11.5/js/dataTables.bootstrap5.min.js"></script>

<!-- Global chart instances -->
<script>
  // Load agents and populate agent/manager dropdowns
  function loadAgentsAndManagers() {
    // Get current filter values
    const division = $("#divisionFilter").val();
    const queue = $("#queueFilter").val();
    const showInactive = $("#showInactive").is(":checked");

    // Build query parameters
    const params = {};
    if (division) params.division = division;
    if (queue) params.queue = queue;
    params.active_only = !showInactive;

    // Show loading state in dropdowns
    $("#agentFilter").html('<option value="">Loading agents...</option>');
    $("#managerFilter").html('<option value="">Loading managers...</option>');

    // Fetch agents with filters
    $.get("/api/agents", params, function (agents) {
      console.log("Loaded", agents.length, "agents for dropdowns");

      // Extract unique managers and sort alphabetically
      const managers = [...new Set(agents.map((a) => a.manager))].sort();

      // Reset dropdowns
      $("#agentFilter").html('<option value="">All Agents</option>');
      $("#managerFilter").html('<option value="">All Managers</option>');

      // Populate agent dropdown
      agents.forEach(function (agent) {
        $("#agentFilter").append(
          $("<option>", {
            value: agent.id,
            text: agent.name,
          })
        );
      });

      // Populate manager dropdown
      managers.forEach(function (manager) {
        $("#managerFilter").append(
          $("<option>", {
            value: manager,
            text: manager,
          })
        );
      });
    }).fail(function (err) {
      console.error("Failed to load agents and managers:", err);
      $("#agentFilter").html('<option value="">Error loading agents</option>');
      $("#managerFilter").html(
        '<option value="">Error loading managers</option>'
      );
    });
  }

  // Function to load dashboard data with improved trend data logging
  function loadDashboardData() {
    // Show loading indicator
    $("#loadingIndicator").show();
    $("#errorAlert").hide();
    $("#noAgentsMessage").hide();

    // Get all filter values
    const division = $("#divisionFilter").val();
    const queue = $("#queueFilter").val();
    const agentId = $("#agentFilter").val();
    const manager = $("#managerFilter").val();
    const startDate = $("#startDateFilter").val();
    const endDate = $("#endDateFilter").val();

    // Build query parameters
    const params = {};
    if (division) params.division = division;
    if (queue) params.queue = queue;
    if (agentId) params.agent_id = agentId;
    if (manager) params.manager = manager;
    if (startDate) params.start_date = startDate;
    if (endDate) params.end_date = endDate;

    console.log("Loading dashboard data with params:", params);

    // Fetch performance stats
    $.get("/api/dashboard_stats", params)
      .done(function (data) {
        console.log("Loaded dashboard data:", data);

        // Hide loading indicator
        $("#loadingIndicator").hide();

        if (data.agents && data.agents.length === 0) {
          $("#noAgentsMessage").show();
          return;
        }

        // Update stats cards
        $("#avgPPL").text(data.avg_ppl ? data.avg_ppl.toFixed(2) : "0.00");
        $("#avgPPLPeriod").text(`Last ${data.period_days || 30} days average`);
        $("#totalAgents").text(data.total_agents || 0);

        // Update agent breakdown text
        const breakdownText = [];
        if (data.above_target)
          breakdownText.push(`${data.above_target} above target`);
        if (data.at_break_even)
          breakdownText.push(`${data.at_break_even} at break-even`);
        if (data.below_break_even)
          breakdownText.push(`${data.below_break_even} below break-even`);

        $("#agentBreakdown").text(
          breakdownText.join(", ") || "No data available"
        );

        // Update performance distribution chart
        updatePerformanceChart(
          data.above_target || 0,
          data.at_break_even || 0,
          data.below_break_even || 0
        );

        // IMPROVED: Enhanced trend data handling with better logging
        console.log("Checking for trend data in response:", data.trend_data);

        // Try multiple approaches to extract trend data
        let trendData = prepareTrendData(data);

        // Update trend chart with extracted data
        if (
          trendData &&
          trendData.labels &&
          trendData.values &&
          trendData.labels.length > 0 &&
          trendData.values.length > 0
        ) {
          console.log("Found valid trend data to display:", trendData);
          updateTrendChart(trendData.labels, trendData.values);
        } else {
          console.warn("No trend data available to display");
          updateTrendChart([], []);

          // Add manual trend generation from agent data if available
          if (data.agents && data.agents.length > 0) {
            generateTrendFromAgentData(data.agents);
          }
        }

        // Update agent table with income projections
        updateAgentTable(data.agents || []);
      })
      .fail(function (jqXHR) {
        console.error("Error loading dashboard data:", jqXHR);
        $("#loadingIndicator").hide();
        $("#errorAlert")
          .show()
          .text(
            jqXHR.responseJSON && jqXHR.responseJSON.error
              ? jqXHR.responseJSON.error
              : "Error loading dashboard data. Please try again."
          );
      });
  }

  // New function to handle different trend data formats
  function prepareTrendData(data) {
    // If no data at all, return null
    if (!data) return null;

    let labels = [];
    let values = [];

    // Case 1: Standard format with labels and values properties
    if (data.trend_data && data.trend_data.labels && data.trend_data.values) {
      console.log("Found standard trend data format");
      return {
        labels: data.trend_data.labels,
        values: data.trend_data.values,
      };
    }

    // Case 2: Array of objects with date and value/ppl properties
    if (data.trend_data && Array.isArray(data.trend_data)) {
      console.log(
        "Found array trend data format, length:",
        data.trend_data.length
      );

      data.trend_data.forEach((point) => {
        if (point.date) labels.push(point.date);
        if ("value" in point) values.push(point.value);
        else if ("ppl" in point) values.push(point.ppl);
        else if ("avg_ppl" in point) values.push(point.avg_ppl);
      });

      if (labels.length > 0 && values.length > 0) {
        return { labels, values };
      }
    }

    // Case 3: Trend data might be directly in the response root
    if (data.dates && Array.isArray(data.dates)) {
      console.log("Found dates array at root level");
      labels = data.dates;

      // Look for corresponding values
      if (data.ppl_values && Array.isArray(data.ppl_values)) {
        values = data.ppl_values;
      } else if (data.values && Array.isArray(data.values)) {
        values = data.values;
      }

      if (labels.length > 0 && values.length > 0) {
        return { labels, values };
      }
    }

    // Case 4: Individual trend points in the response
    if (data.trend_points && Array.isArray(data.trend_points)) {
      console.log("Found trend_points array");
      data.trend_points.forEach((point) => {
        if (point.date) labels.push(point.date);
        if ("value" in point) values.push(point.value);
        else if ("ppl" in point) values.push(point.ppl);
      });

      if (labels.length > 0 && values.length > 0) {
        return { labels, values };
      }
    }

    // If we reached here, no suitable trend data was found
    console.warn("No suitable trend data format found in:", data);
    return null;
  }

  // New function to generate trend data from agent data if no trend data is provided
  function generateTrendFromAgentData(agents) {
    console.log("Attempting to generate trend data from agent data");

    // We'll create a simple trend with a few points
    if (!agents || agents.length === 0) return;

    // Calculate average PPL
    let sum = 0;
    let count = 0;

    agents.forEach((agent) => {
      if (agent.ppl) {
        sum += agent.ppl;
        count++;
      }
    });

    if (count === 0) return;

    const avgPpl = sum / count;

    // Generate dates for the last 3 data points (could be weeks)
    const today = new Date();
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(today.getDate() - 7);
    const twoWeeksAgo = new Date();
    twoWeeksAgo.setDate(today.getDate() - 14);

    // Format dates as strings
    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    };

    // Create synthetic trend data
    // We'll vary the PPL slightly to create a trend
    const labels = [
      formatDate(twoWeeksAgo),
      formatDate(oneWeekAgo),
      formatDate(today),
    ];

    // Vary the values slightly (±5%) to create a realistic trend
    const values = [
      avgPpl * (0.95 + Math.random() * 0.1),
      avgPpl * (0.97 + Math.random() * 0.06),
      avgPpl,
    ];

    console.log("Generated synthetic trend data:", { labels, values });

    // Update the chart with our synthetic data
    updateTrendChart(labels, values);
  }

  // Helper function to update trend chart with improved error handling
  function updateTrendChart(labels, values) {
    console.log("Updating trend chart with:", { labels, values });

    // Make sure we have data to display
    if (!labels || !values || labels.length === 0 || values.length === 0) {
      console.warn("No trend data available to display");

      // Add a no data message to the chart container
      const chartContainer = $("#trendChart").parent();
      if (chartContainer.find(".no-data-message").length === 0) {
        chartContainer.append(
          '<div class="no-data-message text-center text-muted mt-4">No trend data available</div>'
        );
      }

      // Clear the chart
      trendChart.data.labels = [];
      trendChart.data.datasets[0].data = [];
      trendChart.update();

      // Add a button to fetch/generate trend data
      if (chartContainer.find("#generateTrendBtn").length === 0) {
        chartContainer.append(`
          <div class="text-center mt-2">
            <button id="generateTrendBtn" class="btn btn-sm btn-outline-primary">
              <i class="bi bi-arrow-repeat"></i> Generate Trend
            </button>
          </div>
        `);

        // Add click handler for the button
        $("#generateTrendBtn").click(function () {
          // Show loading state
          $(this).html(
            '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...'
          );
          $(this).prop("disabled", true);

          // Try to fetch trend data directly
          $.get("/api/ppl_trend")
            .done(function (data) {
              console.log("Fetched trend data:", data);
              let trendData = prepareTrendData(data);

              if (
                trendData &&
                trendData.labels &&
                trendData.values &&
                trendData.labels.length > 0 &&
                trendData.values.length > 0
              ) {
                updateTrendChart(trendData.labels, trendData.values);
              } else {
                // If no trend data, generate synthetic data
                generateTrendFromAgentData(window.lastAgentData || []);
              }
            })
            .fail(function () {
              // If API fails, generate synthetic data
              generateTrendFromAgentData(window.lastAgentData || []);
            })
            .always(function () {
              // Reset button state
              $("#generateTrendBtn").html(
                '<i class="bi bi-arrow-repeat"></i> Generate Trend'
              );
              $("#generateTrendBtn").prop("disabled", false);
            });
        });
      }

      return;
    }

    // Remove any no data message and generate button
    $("#trendChart")
      .parent()
      .find(".no-data-message, #generateTrendBtn")
      .remove();

    // Format date labels to be more readable if they are dates
    const formattedLabels = labels.map((label) => {
      // Check if this is a date string
      if (typeof label === "string" && label.match(/^\d{4}-\d{2}-\d{2}$/)) {
        const date = new Date(label);
        return date.toLocaleDateString(undefined, {
          month: "short",
          day: "numeric",
        });
      }
      return label;
    });

    // Add a target line at 164 PPL
    const targetDataset = {
      label: "Target PPL",
      data: Array(labels.length).fill(164),
      borderColor: "#198754", // success green
      borderWidth: 2,
      borderDash: [5, 5],
      fill: false,
      pointRadius: 0,
    };

    // Add a break-even line at 130 PPL
    const breakEvenDataset = {
      label: "Break-Even PPL",
      data: Array(labels.length).fill(130),
      borderColor: "#ffc107", // warning yellow
      borderWidth: 2,
      borderDash: [5, 5],
      fill: false,
      pointRadius: 0,
    };

    // Update chart data
    trendChart.data.labels = formattedLabels;
    trendChart.data.datasets[0].data = values;

    // Add reference lines if they don't exist
    if (trendChart.data.datasets.length === 1) {
      trendChart.data.datasets.push(targetDataset);
      trendChart.data.datasets.push(breakEvenDataset);
    } else {
      // Update existing reference lines
      trendChart.data.datasets[1].data = Array(labels.length).fill(164);
      trendChart.data.datasets[2].data = Array(labels.length).fill(130);
    }

    // Adjust y-axis to show more context around the data
    const minValue = Math.min(...values, 0);
    const maxValue = Math.max(...values, 200);
    const padding = (maxValue - minValue) * 0.2; // 20% padding

    trendChart.options.scales.y.min = Math.max(0, minValue - padding);
    trendChart.options.scales.y.max = maxValue + padding;

    // Update the chart
    trendChart.update();
  }

  // Helper function to update performance distribution chart
  function updatePerformanceChart(aboveTarget, atTarget, belowTarget) {
    performanceChart.data.datasets[0].data = [
      aboveTarget,
      atTarget,
      belowTarget,
    ];
    performanceChart.update();
  }

  // Helper function to update agent table with income projections
  function updateAgentTable(agents) {
    const table = $("#agentTable").DataTable();

    // Clear existing data
    table.clear();

    // Store the agent data for trend generation
    window.lastAgentData = agents;

    // Add new data
    agents.forEach(function (agent) {
      const statusBadge = agent.is_active
        ? '<span class="badge bg-success">Active</span>'
        : '<span class="badge bg-secondary">Inactive</span>';

      // Add color styling based on PPL
      let pplClass = "";
      if (agent.ppl) {
        if (agent.ppl >= 164) pplClass = "text-success fw-bold";
        else if (agent.ppl >= 130) pplClass = "text-warning fw-bold";
        else pplClass = "text-danger fw-bold";
      }

      // Format close rate correctly
      let closeRateDisplay;
      if (agent.close_rate) {
        // If close_rate is >= 1, assume it's already a percentage
        closeRateDisplay =
          agent.close_rate >= 1
            ? agent.close_rate.toFixed(1) + "%"
            : (agent.close_rate * 100).toFixed(1) + "%";
      } else {
        closeRateDisplay = "0.0%";
      }

      // Calculate projected annual income based on queue type
      const baseSalary =
        agent.queue_type.toLowerCase() === "training" ? 60000 : 30000;
      const commissionRate =
        agent.queue_type.toLowerCase() === "training" ? 0.05 : 0.2;

      // Extract metrics with proper fallbacks
      const closeRate =
        agent.close_rate >= 1 ? agent.close_rate / 100 : agent.close_rate || 0;

      // IMPORTANT: Extract place rate or use 0.7 (70%) as default if not provided
      const placeRate =
        agent.place_rate >= 1
          ? agent.place_rate / 100
          : agent.place_rate || 0.7; // Default to 70% if not available

      // Use average premium if available, otherwise calculate from total premium
      const avgPremium =
        agent.avg_premium ||
        (agent.total_premium && agent.leads_taken && closeRate
          ? agent.total_premium / (agent.leads_taken * closeRate)
          : 3891.56); // Use company average as fallback

      // Standard lead assumptions based on company model:
      // 7 leads per day × 5 days per week × 50 weeks per year = 1,750 leads per year
      const standardAnnualLeads = 1750;

      // Calculate actual sales (closed leads)
      const annualSales = standardAnnualLeads * closeRate;

      // Apply place rate to get placed policies
      const annualPlacedPolicies = annualSales * placeRate;

      // Calculate annual placed premium
      const annualPlacedPremium = annualPlacedPolicies * avgPremium;

      // Calculate commission income (minimum $5,000)
      const commissionIncome = Math.max(
        annualPlacedPremium * commissionRate,
        5000
      );

      // Calculate total projected income
      const projectedIncome = baseSalary + commissionIncome;

      // Check if agent is eligible to move from training to performance queue
      let eligibilityBadge = "";
      if (agent.queue_type.toLowerCase() === "training" && agent.ppl >= 200) {
        eligibilityBadge =
          '<span class="badge bg-info ms-2" title="Eligible for performance queue if PPL ≥ 200 for 2 consecutive months">Queue Promotion Eligible</span>';
      }

      const actions = `
        <button class="btn btn-sm btn-primary view-agent-btn" data-id="${agent.id}">
          <i class="bi bi-graph-up"></i> View
        </button>
      `;

      table.row.add([
        agent.id,
        agent.name,
        agent.division,
        `${agent.queue_type}${eligibilityBadge}`,
        agent.manager,
        statusBadge,
        Math.round(agent.leads_taken || 0),
        closeRateDisplay,
        `<span class="${pplClass}">${
          agent.ppl ? agent.ppl.toFixed(2) : "0.00"
        }</span>`,
        agent.total_premium ? "$" + agent.total_premium.toFixed(2) : "$0.00",
        `$${projectedIncome.toLocaleString()}`,
        actions,
      ]);
    });

    // Redraw the table
    table.draw();
  }

  // Global chart instances
  let performanceChart;
  let trendChart;
</script>

<!-- Global functions for event handlers -->
<script>
  $(document).ready(function () {
    // Initialize charts
    performanceChart = new Chart($("#performanceChart"), {
      type: "doughnut",
      data: {
        labels: ["Above Target", "At Target", "Below Target"],
        datasets: [
          {
            data: [0, 0, 0],
            backgroundColor: ["#28a745", "#ffc107", "#dc3545"],
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
          legend: {
            position: "right",
          },
        },
        animation: {
          duration: 300,
        },
      },
    });

    trendChart = new Chart($("#trendChart"), {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Average PPL",
            data: [],
            borderColor: "#0d6efd",
            backgroundColor: "rgba(13, 110, 253, 0.1)",
            tension: 0.3,
            fill: true,
            pointRadius: 4,
            pointBackgroundColor: "#0d6efd",
          },
          // Target and break-even lines will be added dynamically
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        scales: {
          y: {
            beginAtZero: true,
            min: 0,
            max: 200,
            ticks: {
              stepSize: 50,
              callback: function (value) {
                return value;
              },
            },
            title: {
              display: true,
              text: "PPL",
            },
          },
          x: {
            grid: {
              display: false,
            },
            ticks: {
              maxTicksLimit: 10,
              maxRotation: 45,
              minRotation: 0,
            },
            title: {
              display: true,
              text: "Date",
            },
          },
        },
        plugins: {
          legend: {
            display: true,
            position: "top",
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                const label = context.dataset.label || "";
                const value = context.parsed.y;
                return `${label}: ${value.toFixed(2)}`;
              },
            },
          },
        },
        elements: {
          point: {
            radius: 4,
          },
          line: {
            borderWidth: 2,
          },
        },
        animation: {
          duration: 300,
        },
      },
    });

    // Initialize DataTable for agent table with the income column
    $("#agentTable").DataTable({
      responsive: true,
      ordering: true,
      searching: true,
      paging: true,
      pageLength: 25,
      lengthMenu: [10, 25, 50, 100],
      language: {
        emptyTable: "No data available",
        zeroRecords: "No matching records found",
      },
      columnDefs: [
        { targets: 0, visible: false }, // Hide ID column
      ],
      order: [[8, "desc"]], // Sort by PPL (column 8) by default
      columns: [
        { title: "ID" },
        { title: "Name" },
        { title: "Division" },
        { title: "Queue" },
        { title: "Manager" },
        { title: "Status" },
        { title: "Leads Taken" },
        { title: "Close Rate" },
        { title: "PPL" },
        { title: "Total Premium" },
        { title: "Projected Annual Income" }, // New column
        { title: "Actions" },
      ],
      drawCallback: function () {
        // Attach click handlers for view buttons after table draw
        $(".view-agent-btn")
          .off("click")
          .on("click", function () {
            const agentId = $(this).data("id");
            // Open agent details modal with this ID
            $("#agentDetailsModal").modal("show");
            loadAgentDetails(agentId);
          });
      },
    });

    // Utility function to show alerts - exposed globally via window.showAlert
    function showAlert(type, message, duration = 5000) {
      // Remove any existing alerts
      $(".alert-floating").remove();

      // Create alert element
      const alertClass = type === "error" ? "danger" : type;
      const alert = $(`
        <div class="alert alert-${alertClass} alert-floating alert-dismissible fade show" role="alert" 
             style="position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;">
          ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
      `);

      // Add to body
      $("body").append(alert);

      // Auto-remove after specified duration
      setTimeout(() => {
        alert.alert("close");
      }, duration);
    }

    // Expose the showAlert function globally
    window.showAlert = showAlert;

    // Add modal cleanup handler
    $("#agentDetailsModal").on("hidden.bs.modal", function () {
      // Remove modal backdrop if it exists
      $(".modal-backdrop").remove();
      // Remove modal-open class from body and reset all modal-related styles
      $("body").removeClass("modal-open").css({
        "padding-right": "",
        overflow: "",
        height: "",
      });
      // Ensure any inline styles affecting scroll behavior are removed
      $(document).css({
        overflow: "",
        "padding-right": "",
      });
      // Force a small delay to ensure cleanup is complete
      setTimeout(() => {
        $("body").css("overflow", "");
        $(window).trigger("resize");
      }, 100);
    });

    // Set default date range (last 30 days)
    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);

    // Format dates as YYYY-MM-DD
    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    };

    // Set default date values
    $("#startDateFilter").val(formatDate(thirtyDaysAgo));
    $("#endDateFilter").val(formatDate(today));

    // Override any saved/cached dates that might be in the future
    const startDateInput = $("#startDateFilter");
    const endDateInput = $("#endDateFilter");

    // Ensure dates are not in the future
    if (new Date(startDateInput.val()) > today) {
      console.log("Correcting future start date to 30 days ago");
      startDateInput.val(formatDate(thirtyDaysAgo));
    }

    if (new Date(endDateInput.val()) > today) {
      console.log("Correcting future end date to today");
      endDateInput.val(formatDate(today));
    }

    // Handle quick date range changes
    $("#quickDateRange").on("change", function () {
      const value = $(this).val();
      const customFields = $(".custom-date-range");

      if (value === "custom") {
        customFields.removeClass("d-none");
      } else {
        customFields.addClass("d-none");

        // Set date range based on selection
        const end = new Date();
        const start = new Date();
        const days = parseInt(value);
        start.setDate(end.getDate() - days);

        // Format dates correctly
        $("#startDateFilter").val(formatDate(start));
        $("#endDateFilter").val(formatDate(end));

        // Show visual feedback
        showAlert("info", `Date range set to last ${days} days`, 1500);

        // Automatically submit form when quick range changes
        // But give a short delay for UI feedback
        setTimeout(() => {
          $("#filterForm").submit();
        }, 100);
      }
    });

    // Handle custom date changes
    $("#startDateFilter, #endDateFilter").on("change", function () {
      if ($("#quickDateRange").val() === "custom") {
        // Check if both dates are selected
        const startDate = $("#startDateFilter").val();
        const endDate = $("#endDateFilter").val();

        if (startDate && endDate) {
          // Validate that start date is before end date
          if (new Date(startDate) > new Date(endDate)) {
            showAlert("error", "Start date cannot be after end date");
            return;
          }

          // Auto-submit when both dates are set in custom mode
          $("#filterForm").submit();
        }
      }
    });

    // Load initial data
    loadAgentsAndManagers();
    loadDashboardData();

    // Handle filter form submission
    $("#filterForm").on("submit", function (e) {
      e.preventDefault();
      console.log("Filter form submitted");
      loadDashboardData();
    });

    // Handle division filter change
    $("#divisionFilter").on("change", function () {
      loadAgentsAndManagers();
      // After loading agents and managers, refresh the dashboard
      loadDashboardData();
    });

    // Handle queue filter change
    $("#queueFilter").on("change", function () {
      loadAgentsAndManagers();
      // After loading agents and managers, refresh the dashboard
      loadDashboardData();
    });

    // Handle show inactive checkbox change
    $("#showInactive").on("change", function () {
      loadAgentsAndManagers();
      loadDashboardData();
    });

    // Remove daily/weekly toggle buttons from both main view and modal
    $('.btn-group:contains("Daily View")').remove();
    $('.btn-group:contains("Daily")').remove();

    // Update the modal title to reflect weekly view
    $('.modal-title:contains("Daily Performance")').text("Weekly Performance");
    $('.card-title:contains("Daily PPL Trend")').text("PPL Trend");

    // Check last sync time on page load
    checkLastSyncTime();

    // Handle manual sync button click
    $("#manualSyncBtn").on("click", function () {
      if (
        confirm(
          "Are you sure you want to sync data from Looker Studio? This may take a few moments."
        )
      ) {
        triggerManualSync();
      }
    });

    // These functions remain in the document ready scope since they are only used here
    function checkLastSyncTime() {
      $.get("/api/last_sync_time")
        .done(function (data) {
          if (data.last_sync) {
            const lastSync = new Date(data.last_sync);
            $("#lastSyncTime").html(
              `Data last synced: ${lastSync.toLocaleString()}`
            );
          } else {
            $("#lastSyncTime").html("Data last synced: Never");
          }
        })
        .fail(function () {
          $("#lastSyncTime").html("Unable to check sync status");
        });
    }

    function triggerManualSync() {
      // Show loading state
      const originalBtnText = $("#manualSyncBtn").html();
      $("#manualSyncBtn").html(
        '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Syncing...'
      );
      $("#manualSyncBtn").attr("disabled", true);

      $.post("/api/trigger_looker_sync")
        .done(function (data) {
          showAlert("success", "Sync completed successfully!");
          checkLastSyncTime();
          loadDashboardData(); // Reload the dashboard data
        })
        .fail(function (jqXHR) {
          const errorMsg =
            jqXHR.responseJSON && jqXHR.responseJSON.error
              ? jqXHR.responseJSON.error
              : "Failed to sync data. Please try again.";
          showAlert("error", errorMsg);
        })
        .always(function () {
          // Reset button state
          $("#manualSyncBtn").html(originalBtnText);
          $("#manualSyncBtn").attr("disabled", false);
        });
    }

    // Store agent data globally for trend generation
    window.lastAgentData = [];
  });
</script>

<!-- Agent Details Modal Functionality -->
<script>
  function loadAgentDetails(agentId) {
    // Show loading indicator in modal
    $("#agentDetailsLoading").removeClass("d-none");
    $("#agentDetailsError").addClass("d-none");
    $("#agentDetailsContent").removeClass("d-none"); // Show content container initially

    // Get date range from filters
    const startDate = $("#startDateFilter").val();
    const endDate = $("#endDateFilter").val();

    // Build query parameters
    const params = {};
    if (startDate) params.start_date = startDate;
    if (endDate) params.end_date = endDate;

    console.log(
      `Loading details for agent ID: ${agentId} with params:`,
      params
    );

    // Add manual forced reload button for testing
    $("#agentDetailsContent").prepend(`
      <div id="debugControls" class="mb-3">
        <button class="btn btn-sm btn-warning" id="forceReloadBtn">Force Reload Data</button>
        <button class="btn btn-sm btn-info ms-2" id="showResponseBtn">Show API Response</button>
        <div id="apiResponseDebug" class="mt-2 d-none">
          <pre class="bg-light p-2" style="max-height: 150px; overflow: auto;"></pre>
        </div>
      </div>
    `);

    // Create a variable to store the response for debugging
    let lastResponse = null;

    // Fetch agent details
    $.get(`/api/agent_details/${agentId}`, params)
      .done(function (data) {
        console.log("Loaded agent details:", data);
        lastResponse = data;

        // Hide loading indicator
        $("#agentDetailsLoading").addClass("d-none");

        // Check if we have valid agent data
        if (!data || !data.agent) {
          $("#agentDetailsError")
            .removeClass("d-none")
            .find(".alert")
            .text("No agent data returned from server.");
          return;
        }

        // Fix: Handle different API response structure - API returns performance_data instead of performances
        const performances = data.performances || data.performance_data || [];

        // Check if we have performances data
        if (performances.length === 0) {
          console.warn("No performance data found for agent");
        }

        // Populate agent info
        $("#agentName").text(data.agent.name || "");
        $("#agentDivision").text(data.agent.division || "");
        $("#agentManager").text(data.agent.manager || "");
        $("#agentQueue").text(data.agent.queue_type || "");

        // Calculate stats if not provided by the API
        let stats = data.stats;
        if (!stats && performances.length > 0) {
          console.log(
            "Stats not provided by API, calculating from performance data"
          );
          stats = calculateStatsFromPerformances(performances);
        } else {
          console.log("Agent stats data:", stats);
        }

        // Calculate total leads from performances if not in stats or if it's zero
        let totalLeads = 0;
        if (performances && performances.length > 0) {
          performances.forEach((perf) => {
            if (typeof perf.leads_taken === "number") {
              totalLeads += perf.leads_taken;
            }
          });
        }

        // Populate performance summary - ensure we display correct total leads
        $("#avgPPLDetails").text(
          stats && typeof stats.avg_ppl === "number"
            ? stats.avg_ppl.toFixed(2)
            : "0.00"
        );

        // Use calculated total leads if available, otherwise use stats
        $("#totalLeadsDetails").text(
          totalLeads > 0
            ? totalLeads
            : stats && typeof stats.total_leads === "number"
            ? Math.round(stats.total_leads)
            : performances.length
        );

        // Update "Add Performance" button link
        $("#addPerformanceBtn").attr(
          "href",
          `/add_performance?agent_id=${agentId}`
        );

        // Create metrics chart if we have stats
        if (stats) {
          createAgentMetricsChart(stats);
        } else {
          // Clear the chart if no data
          clearChart("agentMetricsChart");
        }

        // Create trend chart if data available
        if (
          data.trend_data &&
          data.trend_data.labels &&
          data.trend_data.labels.length > 0 &&
          data.trend_data.values &&
          data.trend_data.values.length > 0
        ) {
          createAgentTrendChart(data.trend_data.labels, data.trend_data.values);
        } else if (performances.length > 0) {
          // If no trend data but we have performances, create a trend from that
          const labels = performances.map((p) => p.date);
          const values = performances.map((p) => p.ppl);
          createAgentTrendChart(labels, values);
        } else {
          // Clear the chart if no data
          clearChart("agentTrendChart");
        }

        // Log performances data for debugging
        console.log("Agent performances data:", performances);

        // Add event handlers for debug buttons
        $("#forceReloadBtn").on("click", function () {
          console.log("Forcing data reload for agent", agentId);

          // Show loading indicators again
          $("#agentDetailsLoading").removeClass("d-none");

          // Add a cache-busting parameter
          const newParams = { ...params, _t: new Date().getTime() };

          // Make a new request with cache busting
          $.get(`/api/agent_details/${agentId}`, newParams)
            .done(function (newData) {
              console.log("Force reload data:", newData);
              // Store response and update the pre tag
              lastResponse = newData;
              $("#apiResponseDebug pre").text(JSON.stringify(newData, null, 2));

              // Hide loading indicator
              $("#agentDetailsLoading").addClass("d-none");

              // Fix: Handle different API response structure
              const newPerformances =
                newData.performances || newData.performance_data || [];

              if (newPerformances && newPerformances.length > 0) {
                // If we got data this time, update the table
                populateAgentDetailsTable(newPerformances);
                // Show success message
                window.showAlert(
                  "success",
                  "Successfully loaded agent performance data"
                );
              } else {
                window.showAlert(
                  "warning",
                  "No performance data available for this agent"
                );
              }
            })
            .fail(function (jqXHR) {
              $("#agentDetailsLoading").addClass("d-none");
              window.showAlert(
                "error",
                "Failed to load agent details on retry"
              );
            });
        });

        $("#showResponseBtn").on("click", function () {
          const $debug = $("#apiResponseDebug");
          if ($debug.hasClass("d-none")) {
            $debug.removeClass("d-none");
            $("#apiResponseDebug pre").text(
              JSON.stringify(lastResponse, null, 2)
            );
          } else {
            $debug.addClass("d-none");
          }
        });

        // Populate details table
        populateAgentDetailsTable(performances);
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error("Error loading agent details:", textStatus, errorThrown);
        console.error("Response:", jqXHR.responseText);
        $("#agentDetailsLoading").addClass("d-none");
        $("#agentDetailsError").removeClass("d-none");
        $("#agentDetailsError")
          .find(".alert")
          .text(
            jqXHR.responseJSON && jqXHR.responseJSON.error
              ? jqXHR.responseJSON.error
              : `Failed to load agent details: ${textStatus}`
          );
      });
  }

  // Helper function to clear charts safely
  function clearChart(chartId) {
    const ctx = document.getElementById(chartId).getContext("2d");
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Safely destroy existing chart
    if (window[chartId]) {
      if (typeof window[chartId].destroy === "function") {
        window[chartId].destroy();
      }
      window[chartId] = null;
    }
  }

  // Calculate stats from performance data if the API doesn't provide them
  function calculateStatsFromPerformances(performances) {
    if (!performances || performances.length === 0) {
      return null;
    }

    // Calculate average metrics
    let totalPPL = 0;
    let totalCloseRate = 0;
    let totalPlaceRate = 0;
    let totalPremium = 0;
    let totalLeads = 0;
    let totalIncome = 0;

    performances.forEach((perf) => {
      // Extract values with proper type checking
      const ppl = typeof perf.ppl === "number" ? perf.ppl : 0;
      const closeRate =
        typeof perf.close_rate === "number"
          ? perf.close_rate >= 1
            ? perf.close_rate / 100
            : perf.close_rate
          : 0;
      const placeRate =
        typeof perf.place_rate === "number"
          ? perf.place_rate >= 1
            ? perf.place_rate / 100
            : perf.place_rate
          : 0;
      const avgPremium =
        typeof perf.avg_premium === "number" ? perf.avg_premium : 0;
      const leads = typeof perf.leads_taken === "number" ? perf.leads_taken : 0;

      totalPPL += ppl;
      totalCloseRate += closeRate;
      totalPlaceRate += placeRate;
      totalPremium += avgPremium;
      totalLeads += leads;

      // Calculate estimated income for this period
      const estimatedSales = leads * closeRate;
      const estimatedPlacements = estimatedSales * placeRate;
      const estimatedIncome = estimatedPlacements * avgPremium;
      totalIncome += estimatedIncome;
    });

    const count = performances.length;

    return {
      avg_ppl: totalPPL / count,
      avg_close_rate: totalCloseRate / count,
      avg_place_rate: totalPlaceRate / count,
      avg_premium: totalPremium / count,
      total_leads: totalLeads,
      total_income: totalIncome,
    };
  }

  // Helper function to create agent metrics chart
  function createAgentMetricsChart(stats) {
    const ctx = document.getElementById("agentMetricsChart").getContext("2d");

    // Safely destroy existing chart
    if (window.agentMetricsChart) {
      if (typeof window.agentMetricsChart.destroy === "function") {
        window.agentMetricsChart.destroy();
      }
    }

    // Ensure stats has all expected values, use defaults if missing
    const closeRate = (stats.avg_close_rate || 0) * 100;
    const placeRate = (stats.avg_place_rate || 0) * 100;
    const avgPremium = stats.avg_premium || 0;

    // Create new chart with dual Y axes
    window.agentMetricsChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels: ["Close Rate", "Place Rate", "Avg Premium"],
        datasets: [
          {
            label: "Rates (%)",
            data: [closeRate, placeRate, null],
            backgroundColor: [
              "rgba(13, 110, 253, 0.7)",
              "rgba(25, 135, 84, 0.7)",
            ],
            borderColor: ["rgba(13, 110, 253, 1)", "rgba(25, 135, 84, 1)"],
            borderWidth: 1,
            yAxisID: "y",
          },
          {
            label: "Premium ($)",
            data: [null, null, avgPremium],
            backgroundColor: "rgba(220, 53, 69, 0.7)",
            borderColor: "rgba(220, 53, 69, 1)",
            borderWidth: 1,
            yAxisID: "y1",
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            type: "linear",
            display: true,
            position: "left",
            title: {
              display: true,
              text: "Percentage (%)",
            },
            min: 0,
            max: 100,
            ticks: {
              callback: function (value) {
                return value + "%";
              },
            },
          },
          y1: {
            type: "linear",
            display: true,
            position: "right",
            title: {
              display: true,
              text: "Premium ($)",
            },
            min: 0,
            grid: {
              drawOnChartArea: false,
            },
            ticks: {
              callback: function (value) {
                return "$" + value;
              },
            },
          },
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function (context) {
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  if (context.datasetIndex === 0) {
                    label += context.parsed.y.toFixed(1) + "%";
                  } else {
                    label += "$" + context.parsed.y.toFixed(2);
                  }
                }
                return label;
              },
            },
          },
        },
      },
    });

    // Also create an income trend chart if we have performance data
    createIncomeEstimateChart(stats);
  }

  // Improved income projection for agent details
  function createIncomeEstimateChart(stats) {
    // Create a div for the income chart if it doesn't exist
    if (!$("#incomeChartContainer").length) {
      // Add the income chart after the metrics chart
      $("#agentMetricsChart").closest(".card").after(`
        <div class="card mt-3">
          <div class="card-body">
            <h6 class="card-title">Income Projection</h6>
            <div style="height: 150px; position: relative">
              <canvas id="incomeEstimateChart"></canvas>
            </div>
          </div>
        </div>
      `);
    }

    const ctx = document.getElementById("incomeEstimateChart").getContext("2d");

    // Safely destroy existing chart
    if (window.incomeEstimateChart) {
      if (typeof window.incomeEstimateChart.destroy === "function") {
        window.incomeEstimateChart.destroy();
      }
    }

    // Get queue type from agent info
    const queueType = $("#agentQueue").text().toLowerCase().trim();
    const isTraining = queueType.includes("training");

    // Set commission rates and base salary based on queue type
    const commissionRate = isTraining ? 0.05 : 0.2; // 5% for training, 20% for performance
    const baseSalary = isTraining ? 60000 : 30000; // $60k for training, $30k for performance

    // Calculate important income metrics with PLACE RATE included
    const avgPremium = stats.avg_premium || 3891.56; // Use company average as fallback
    const closeRate = stats.avg_close_rate || 0.28; // Default to 28% if not available
    const placeRate = stats.avg_place_rate || 0.7; // Default to 70% if not available

    // Standard lead assumptions (7 leads/day × 5 days/week × 50 weeks/year)
    const standardAnnualLeads = 1750;

    // Sales calculation
    const annualSales = standardAnnualLeads * closeRate;

    // Placed policies calculation with place rate
    const annualPlacedPolicies = annualSales * placeRate;

    // Annual placed premium
    const annualPlacedPremium = annualPlacedPolicies * avgPremium;

    // Make sure there's a minimum commission of $5,000
    const commissionIncome = Math.max(
      annualPlacedPremium * commissionRate,
      5000
    );
    const totalIncome = baseSalary + commissionIncome;

    // Create projection for alternative scenario (if moved to other queue)
    const altCommissionRate = isTraining ? 0.2 : 0.05;
    const altBaseSalary = isTraining ? 30000 : 60000;
    const altCommissionIncome = Math.max(
      annualPlacedPremium * altCommissionRate,
      5000
    );
    const altTotalIncome = altBaseSalary + altCommissionIncome;

    // Calculate PPL threshold for training agents
    const ppl = stats.avg_ppl || 0;
    const isEligibleForPromotion = isTraining && ppl >= 200;

    // Create a bar chart for income projections
    window.incomeEstimateChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels: [
          `Current (${isTraining ? "Training" : "Performance"})`,
          `If ${isTraining ? "Promoted" : "Demoted"}`,
        ],
        datasets: [
          {
            label: "Base Salary",
            data: [baseSalary, altBaseSalary],
            backgroundColor: "rgba(23, 162, 184, 0.7)",
            borderColor: "rgba(23, 162, 184, 1)",
            borderWidth: 1,
          },
          {
            label: "Commission",
            data: [commissionIncome, altCommissionIncome],
            backgroundColor: "rgba(255, 193, 7, 0.7)",
            borderColor: "rgba(255, 193, 7, 1)",
            borderWidth: 1,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            stacked: true,
          },
          y: {
            stacked: true,
            beginAtZero: true,
            ticks: {
              callback: function (value) {
                return "$" + value.toLocaleString();
              },
            },
          },
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function (context) {
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  label += "$" + context.parsed.y.toFixed(2);
                }
                return label;
              },
              footer: function (tooltipItems) {
                let sum = 0;
                tooltipItems.forEach(function (tooltipItem) {
                  sum += tooltipItem.parsed.y;
                });
                return "Total: $" + sum.toLocaleString();
              },
            },
          },
        },
      },
    });

    // Add eligibility notice for training agents
    if (isTraining) {
      const noticeHtml = isEligibleForPromotion
        ? `<div class="alert alert-success mt-2">
          <i class="bi bi-check-circle-fill"></i> This agent appears to be eligible for promotion to the performance queue based on current PPL of ${ppl.toFixed(
            2
          )}.
          <br><small class="text-muted">Note: Requires PPL ≥ 200 for 2 consecutive months.</small>
        </div>`
        : `<div class="alert alert-info mt-2">
          <i class="bi bi-info-circle-fill"></i> This agent needs to achieve a PPL of 200+ for 2 consecutive months to be eligible for promotion to the performance queue.
          <br><small class="text-muted">Current PPL: ${ppl.toFixed(2)}</small>
        </div>`;

      $("#incomeEstimateChart").closest(".card-body").append(noticeHtml);
    }

    // Add detailed income projection breakdown
    $("#incomeEstimateChart").closest(".card-body").append(`
      <div class="mt-2 small text-muted">
        <p><strong>Annual Income Projection Details:</strong></p>
        <ul>
          <li>Base Salary: ${isTraining ? "$60,000" : "$30,000"}</li>
          <li>Lead Volume: 7 leads/day × 5 days/week × 50 weeks/year = 1,750 leads</li>
          <li>Close Rate: ${(closeRate * 100).toFixed(1)}% → ${Math.round(
      annualSales
    )} sales/year</li>
          <li>Place Rate: ${(placeRate * 100).toFixed(1)}% → ${Math.round(
      annualPlacedPolicies
    )} placed policies/year</li>
          <li>Average Premium: $${avgPremium.toFixed(2)}</li>
          <li>Annual Placed Premium: $${annualPlacedPremium.toLocaleString()}</li>
          <li>Commission (${
            isTraining ? "5%" : "20%"
          }): $${commissionIncome.toLocaleString()}</li>
          <li><strong>Total Projected Income: $${totalIncome.toLocaleString()}</strong></li>
        </ul>
      </div>
    `);
  }

  // Helper function to create agent trend chart
  function createAgentTrendChart(labels, values) {
    const ctx = document.getElementById("agentTrendChart").getContext("2d");

    // Safely destroy existing chart
    if (window.agentTrendChart) {
      if (typeof window.agentTrendChart.destroy === "function") {
        window.agentTrendChart.destroy();
      }
    }

    // Create new chart
    window.agentTrendChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          {
            label: "PPL",
            data: values,
            borderColor: "rgba(13, 110, 253, 1)",
            backgroundColor: "rgba(13, 110, 253, 0.1)",
            tension: 0.1,
            fill: true,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            min: 0,
            suggestedMax: 200,
          },
        },
      },
    });
  }

  // Helper function to populate agent details table
  function populateAgentDetailsTable(performances) {
    const table = $("#agentDetailsTable");
    const tbody = table.find("tbody");

    // Clear existing data
    tbody.empty();

    if (!performances || performances.length === 0) {
      tbody.html(
        `<tr><td colspan="7" class="text-center">No performance data available</td></tr>`
      );
      return;
    }

    // Sort performances by date (newest first)
    performances.sort((a, b) => new Date(b.date) - new Date(a.date));

    // Add rows for each performance record
    performances.forEach(function (perf, index) {
      console.log("Processing performance record:", perf);

      // Ensure we have valid numeric values, use defaults if missing or invalid
      const ppl = typeof perf.ppl === "number" ? perf.ppl : 0;
      const leadsNum =
        typeof perf.leads_taken === "number" ? perf.leads_taken : 0;

      // Handle percentage values correctly
      let closeRate, placeRate;

      if (typeof perf.close_rate === "number") {
        // If close_rate is >= 1, assume it's already a percentage
        closeRate =
          perf.close_rate >= 1 ? perf.close_rate : perf.close_rate * 100;
      } else {
        closeRate = 0;
      }

      if (typeof perf.place_rate === "number") {
        // If place_rate is >= 1, assume it's already a percentage
        placeRate =
          perf.place_rate >= 1 ? perf.place_rate : perf.place_rate * 100;
      } else {
        placeRate = 0;
      }

      const avgPremium =
        typeof perf.avg_premium === "number" ? perf.avg_premium : 0;

      // Calculate week-over-week changes if not the first record
      let pplChangeHtml = "";
      let closeRateChangeHtml = "";
      let placeRateChangeHtml = "";
      let premiumChangeHtml = "";

      if (index < performances.length - 1) {
        const prevPerf = performances[index + 1];

        // PPL change
        if (prevPerf.ppl && prevPerf.ppl > 0) {
          const pplChange = ((ppl - prevPerf.ppl) / prevPerf.ppl) * 100;
          const pplIcon =
            pplChange >= 0
              ? '<i class="bi bi-arrow-up-circle-fill text-success"></i>'
              : '<i class="bi bi-arrow-down-circle-fill text-danger"></i>';
          pplChangeHtml = ` ${pplIcon} <small class="text-muted">(${Math.abs(
            pplChange
          ).toFixed(1)}%)</small>`;
        }

        // Close rate change
        if (prevPerf.close_rate && prevPerf.close_rate > 0) {
          const prevCloseRate =
            prevPerf.close_rate >= 1
              ? prevPerf.close_rate
              : prevPerf.close_rate * 100;
          const closeRateChange =
            ((closeRate - prevCloseRate) / prevCloseRate) * 100;
          const closeRateIcon =
            closeRateChange >= 0
              ? '<i class="bi bi-arrow-up-circle-fill text-success"></i>'
              : '<i class="bi bi-arrow-down-circle-fill text-danger"></i>';
          closeRateChangeHtml = ` ${closeRateIcon} <small class="text-muted">(${Math.abs(
            closeRateChange
          ).toFixed(1)}%)</small>`;
        }

        // Place rate change
        if (prevPerf.place_rate && prevPerf.place_rate > 0) {
          const prevPlaceRate =
            prevPerf.place_rate >= 1
              ? prevPerf.place_rate
              : prevPerf.place_rate * 100;
          const placeRateChange =
            ((placeRate - prevPlaceRate) / prevPlaceRate) * 100;
          const placeRateIcon =
            placeRateChange >= 0
              ? '<i class="bi bi-arrow-up-circle-fill text-success"></i>'
              : '<i class="bi bi-arrow-down-circle-fill text-danger"></i>';
          placeRateChangeHtml = ` ${placeRateIcon} <small class="text-muted">(${Math.abs(
            placeRateChange
          ).toFixed(1)}%)</small>`;
        }

        // Premium change
        if (prevPerf.avg_premium && prevPerf.avg_premium > 0) {
          const premiumChange =
            ((avgPremium - prevPerf.avg_premium) / prevPerf.avg_premium) * 100;
          const premiumIcon =
            premiumChange >= 0
              ? '<i class="bi bi-arrow-up-circle-fill text-success"></i>'
              : '<i class="bi bi-arrow-down-circle-fill text-danger"></i>';
          premiumChangeHtml = ` ${premiumIcon} <small class="text-muted">(${Math.abs(
            premiumChange
          ).toFixed(1)}%)</small>`;
        }
      }

      // Status class based on PPL threshold
      const statusClass =
        ppl >= 164 ? "success" : ppl >= 130 ? "warning" : "danger";

      const row = `
        <tr>
          <td>${perf.date || "N/A"}</td>
          <td>${Math.round(leadsNum)}</td>
          <td>${closeRate.toFixed(1)}%${closeRateChangeHtml}</td>
          <td>${placeRate.toFixed(1)}%${placeRateChangeHtml}</td>
          <td>$${avgPremium.toFixed(2)}${premiumChangeHtml}</td>
          <td class="fw-bold text-${statusClass}">${ppl.toFixed(
        2
      )}${pplChangeHtml}</td>
          <td>
            <span class="badge bg-${statusClass}">
              ${
                ppl >= 164
                  ? "Above Target"
                  : ppl >= 130
                  ? "At Break-Even"
                  : "Below Break-Even"
              }
            </span>
          </td>
        </tr>
      `;

      tbody.append(row);
    });
  }
</script>
{% endblock %}
